#!/usr/bin/env bash

# SPDX-License-Identifier: BSD-3-Clause
# SPDX-FileCopyrightText: Copyright 2023 Edwin Kofler and contributors
# @name Bake
# @brief Bake: A Bash-based Make alternative
# @description Bake is a dead-simple task runner used to quickly cobble together shell scripts
#
# In a few words, Bake lets you call the following 'print' task with './bake print'
#
# ```bash
# #!/usr/bin/env bash
# task.print() {
# printf '%s\n' 'Contrived example'
# }
# ```
#
# Learn more about it [on GitHub](https://github.com/hyperupcall/bake)

__global_bake_version='1.11.2+dev'

# Return early if only the version is needed. This improves performance
if [ "$BAKE_INTERNAL_ONLY_VERSION" = 'yes' ]; then
	return 0
fi

# Source guard
if [ "$0" != "${BASH_SOURCE[0]}" ] && [ "$BAKE_INTERNAL_CAN_SOURCE" != 'yes' ]; then
	printf '%s\n' 'Error: This file should not be sourced' >&2
	return 1
fi

# @description Prints `$1` formatted as an error and the stacktrace to standard error,
# then exits with code 1
# @arg $1 string Text to print
bake.die() {
	if [ -n "$1" ]; then
		__bake_error "$1. Exiting"
	else
		__bake_error 'Exiting'
	fi
	__bake_print_big --show-time '<- ERROR'

	__bake_print_stacktrace

	exit 1
}

# @description Prints `$1` formatted as a warning to standard error
# @arg $1 string Text to print
bake.warn() {
	if __bake_is_color; then
		printf "\033[1;33m%s:\033[0m %s\n" 'Warn' "$1"
	else
		printf '%s: %s\n' 'Warn' "$1"
	fi
} >&2

# @description Prints `$1` formatted as information to standard output
# @arg $1 string Text to print
bake.info() {
	if __bake_is_color; then
		printf "\033[0;34m%s:\033[0m %s\n" 'Info' "$1"
	else
		printf '%s: %s\n' 'Info' "$1"
	fi
}

# @description Dies if any of the supplied variables are empty
# @arg $@ string Names of variables to check for emptiness
bake.assert_not_empty() {
	local variable_name=
	for variable_name; do
		local -n ____variable="$variable_name"

		if [ -z "$____variable" ]; then
			bake.die "Failed because variable '$variable_name' is empty"
		fi
	done; unset -v variable_name
}

# @description Dies if a command cannot be found
# @arg $1 string Command name to test for existence
bake.assert_cmd() {
	local cmd=$1

	if [ -z "$cmd" ]; then
		bake.die "Argument must not be empty"
	fi

	if ! command -v "$cmd" &>/dev/null; then
		bake.die "Failed to find command '$cmd'. Please install it before continuing"
	fi
}

# @description Determine if a flag was passed as an argument
# @arg $1 string Flag name to test for
# @arg $@ string Rest of the arguments to search through
bake.has_flag() {
	local flag_name="$1"

	if [ -z "$flag_name" ]; then
		bake.die "Argument must not be empty"
	fi
	if ! shift; then
		bake.die 'Failed to shift'
	fi

	local -a flags=("$@")
	if ((${#flags[@]} == 0)); then
		flags=("${__bake_args_userflags[@]}")
	fi

	local arg=
	for arg in "${flags[@]}"; do
		if [ "$arg" = "$flag_name" ]; then
			return 0
		fi
	done; unset -v arg

	return 1
}

# @description Prints stacktrace
# @internal
__bake_print_stacktrace() {
	if [ "${__bake_config_map[stacktrace]}" = 'on' ]; then
		if __bake_is_color; then
			printf '\033[4m%s\033[0m\n' 'Stacktrace:'
		else
			printf '%s\n' 'Stacktrace:'
		fi

		local i=
		for ((i=0; i<${#FUNCNAME[@]}-1; ++i)); do
			local __bash_source="${BASH_SOURCE[$i]}"; __bash_source=${__bash_source##*/}
			printf '%s\n' "  in ${FUNCNAME[$i]} ($__bash_source:${BASH_LINENO[$i-1]})"
		done; unset -v i __bash_source
	fi
} >&2

# @description Function that is executed when the 'ERR' event is trapped
# @internal
__bake_trap_err() {
	local error_code=$?

	__bake_print_big --show-time '<- ERROR'
	__bake_internal_error "Your Bakefile did not exit successfully (exit code $error_code)"
	__bake_print_stacktrace

	exit $error_code
} >&2

# @description When running a task, ensure that we start in the correct directory
# @internal
__bake_trap_debug_fixcd_current_fn=
__bake_trap_debug_fixcd() {
	local current_function="${FUNCNAME[1]}"

	if [[ $current_function != "$__bake_trap_debug_fixcd_current_fn" \
			&& $current_function == task.* ]]; then
		if ! cd -- "$BAKE_ROOT"; then
			__bake_internal_die "Failed to cd to \$BAKE_ROOT"
		fi
	fi

	__bake_trap_debug_fixcd_current_fn=$current_function
} >&2

# @description Ensure that the main function is not ran
# @internal
__bake_trap_debug_barrier() {
	local current_function="${FUNCNAME[1]}"

	# We don't check for '__bake_entrypoint', since
	if [ "$current_function" = '__bake_main' ]; then
		# shellcheck disable=SC2034
		local __version_old="$__global_bake_version"

		trap - DEBUG
		unset -v BAKE_INTERNAL_ONLY_VERSION
		unset -v BAKE_INTERNAL_CAN_SOURCE

		__bake_setup_copy_bakescript
		if [ "$BAKE_INTERNAL_FLAG_UPDATE" = 'yes' ]; then
			exit 0
		else
			# shellcheck disable=SC2154
			exec "$BAKE_ROOT/bake" "${__bake_global_backup_args[@]}"
		fi
	fi
}

# @description Test whether color should be outputed
# @exitcode 0 if should print color
# @exitcode 1 if should not print color
# @internal
__bake_is_color() {
	local fd="1"

	if [ ${NO_COLOR+x} ]; then
		return 1
	fi

	if [[ $FORCE_COLOR == @(1|2|3) ]]; then
		return 0
	elif [[ $FORCE_COLOR == '0' ]]; then
		return 1
	fi

	if [ "$TERM" = 'dumb' ]; then
		return 1
	fi

	if [ -t "$fd" ]; then
		return 0
	fi

	return 1
}

# @description Calls `__bake_internal_error` and terminates with code 1
# @arg $1 string Text to print
# @internal
__bake_internal_die() {
	__bake_internal_error "$1. Exiting"
	exit 1
}

# @description Calls `__bake_internal_error` and terminates with code 1. Before
# doing so, it closes with "<- ERROR" big text
# @arg $1 string Text to print
# @internal
__bake_internal_bigdie() {
	__bake_print_big '<- ERROR'

	__bake_internal_error "$1. Exiting"
	exit 1
}

# @description Prints `$1` formatted as an internal Bake error to standard error
# @arg $1 Text to print
# @internal
__bake_internal_error() {
	if __bake_is_color; then
		printf "\033[0;31m%s:\033[0m %s\n" "Error (bake)" "$1"
	else
		printf '%s: %s\n' 'Error (bake)' "$1"
	fi
} >&2

# @description Prints `$1` formatted as an internal Bake warning to standard error
# @arg $1 Text to print
# @internal
__bake_internal_warn() {
	if __bake_is_color; then
		printf "\033[0;33m%s:\033[0m %s\n" "Warn (bake)" "$1"
	else
		printf '%s: %s\n' 'Warn (bake)' "$1"
	fi
} >&2

# @description Prints `$1` formatted as an error to standard error. This is not called because
# I do not wish to surface a public 'bake.error' function. All errors should halt execution
# @arg $1 string Text to print
# @internal
__bake_error() {
	if __bake_is_color; then
		printf "\033[0;31m%s:\033[0m %s\n" 'Error' "$1"
	else
		printf '%s: %s\n' 'Error' "$1"
	fi
} >&2

# @description Prepares internal variables for time setting
# @internal
__bake_time_prepare() {
	if ((BASH_VERSINFO[0] >= 5)); then
		__bake_global_timestart=$EPOCHSECONDS
	fi
}

# @description Determines total approximate execution time of a task
# @set string REPLY
# @internal
__bake_time_get_total_pretty() {
	unset -v REPLY; REPLY=

	if ((BASH_VERSINFO[0] >= 5)); then
		local timediff=$((EPOCHSECONDS - __bake_global_timestart))

		if ((timediff < 1)); then
			return 0
		fi

		local seconds=$((timediff % 60))
		local minutes=$((timediff / 60 % 60))
		local hours=$((timediff / 3600 % 60))

		REPLY="${seconds}s"

		if ((minutes > 0)); then
			REPLY="${minutes}m $REPLY"
		fi

		if ((hours > 0)); then
			REPLY="${hours}h $REPLY"
		fi
	fi
}

# @description Parses the configuration for functions embeded in comments. This properly
# parses inherited config from the 'init' function
# @set string __bake_config_docstring
# @set array __bake_config_watchexec_args
# @set object __bake_config_map
# @internal
__bake_parse_task_comments() {
	local flag_all=
	if [ "$1" == '--all' ]; then
		flag_all='yes'
		local fn="$2"
	else
		local task_name="$1"
	fi

	local tmp_docstring=
	local -a tmp_watch_args=()
	local -A tmp_cfg_map=()
	local line=
	while IFS= read -r line || [ -n "$line" ]; do
		if [[ $line =~ ^[[:space:]]*#[[:space:]]*(doc|watch|config):[[:space:]]*(.*?)$ ]]; then
			local comment_category="${BASH_REMATCH[1]}"
			local comment_content="${BASH_REMATCH[2]}"

			if [[ "$comment_content" == *,* ]]; then
				__bake_internal_warn "Use spaces as delimiters rather than commas"
			fi

			if [ "$comment_category" = 'doc' ]; then
				tmp_docstring=$comment_content
			elif [ "$comment_category" = 'watch' ]; then
				readarray -td' ' tmp_watch_args <<< "$comment_content"
				tmp_watch_args[-1]=${tmp_watch_args[-1]::-1}
			elif [ "$comment_category" = 'config' ]; then
				local -a pairs=()
				readarray -td' ' pairs <<< "$comment_content"
				pairs[-1]=${pairs[-1]::-1}

				# shellcheck disable=SC1007
				local pair= key= value=
				for pair in "${pairs[@]}"; do
					IFS='=' read -r key value <<< "$pair"

					tmp_cfg_map[$key]=${value:-on}
				done; unset -v pair
			fi
		fi

		# function()
		if [[ $line =~ ^([[:space:]]*function[[:space:]]*)?(.*?)[[:space:]]*\(\)[[:space:]]*\{ ]]; then
			local function_name="${BASH_REMATCH[2]}"

			if [ "$flag_all" = 'yes' ]; then
				"$fn" "$function_name"
			else
				if [ "$function_name" == task."$task_name" ]; then
					__bake_config_docstring=$tmp_docstring

					__bake_config_watchexec_args+=("${tmp_watch_args[@]}")

					local key=
					for key in "${!tmp_cfg_map[@]}"; do
						__bake_config_map[$key]=${tmp_cfg_map[$key]}
					done; unset -v key

					break
				# TODO: only do this if not overriding (init function could be after tasks)
				elif [ "$function_name" == 'init' ]; then
					__bake_config_watchexec_args+=("${tmp_watch_args[@]}")

					local key=
					for key in "${!tmp_cfg_map[@]}"; do
						__bake_config_map[$key]=${tmp_cfg_map[$key]}
					done; unset -v key
				fi

				tmp_docstring=
				tmp_watch_args=()
				tmp_cfg_map=()
			fi
		fi
	done < "$BAKE_FILE"; unset -v line
}

# @description Nicely prints all 'Bakefile.sh' tasks to standard output
# @internal
__bake_print_tasks() {
	local str=$'Tasks:\n'

	__bake_parse_task_comments --all '__bake_print_tasks_handler'

	printf '%s' "$str"
} >&2

# @internal
__bake_print_tasks_handler() {
	local fn_name="$1"

	if [[ "$fn_name" =~ task.(.*) ]]; then
		local task_name="${BASH_REMATCH[1]}"

		str+="  -> $task_name ($tmp_docstring)"$'\n'
	fi
}

# @description Prints text that takes up the whole terminal width
# @arg $1 string Text to print
# @internal
__bake_print_big() {
	if [ "${__bake_config_map[big-print]}" = 'off' ]; then
		return 0
	fi

	if [ "$1" = '--show-time' ]; then
		local flag_show_time='yes'
		local print_text="$2"
	else
		local flag_show_time='no'
		local print_text="$1"
	fi

	__bake_time_get_total_pretty
	local time_str="${REPLY:+ ($REPLY) }"

	# shellcheck disable=SC1007
	local output= _stty_width=
	if output=$(stty size 2>&1); then
		_stty_width=${output##* }
	else
		if [ -n "$COLUMNS" ]; then
			_stty_width="$COLUMNS"
		else
			_stty_width='80'
		fi
	fi; unset -v output

	local separator_text=
	# shellcheck disable=SC2183
	printf -v separator_text '%*s' $((_stty_width - ${#print_text} - 1))
	printf -v separator_text '%s' "${separator_text// /=}"
	if [[ "$flag_show_time" == 'yes' && -n "$time_str" ]]; then
		separator_text="${separator_text::5}${time_str}${separator_text:5+${#time_str}:${#separator_text}}"
	fi
	if __bake_is_color; then
		printf '\033[1m%s %s\033[0m\n' "$print_text" "$separator_text" >&2
	else
		printf '%s %s\n' "$print_text" "$separator_text" >&2
	fi
}

# @description Parses the arguments. This also includes setting the the 'BAKE_ROOT'
# and 'BAKE_FILE' variables
# @set REPLY Number of times to shift
# @internal
__bake_parse_args() {
	unset -v REPLY; REPLY=
	local -i total_shifts=0

	if [ "$BAKE_INTERNAL_HAS_PARSED_ARGS" = 'yes' ]; then
		REPLY=$total_shifts
		return
	fi

	# shellcheck disable=SC1007
	local __bake_key= __bake_value= __bake_arg= __bake_flag_help=
	for __bake_arg; do case $__bake_arg in
	-f?*)
		bake.die "Flag '-f' must be specified after all other flags"
		;;
	-*)
		((total_shifts += 1))
		if ! shift; then
			__bake_internal_die 'Failed to shift'
		fi

		if [[ $__bake_arg == -*f* ]]; then
			BAKE_FILE=$1
			if [ -z "$BAKE_FILE" ]; then
				__bake_internal_die "A value was not specified for for flag '-f'"
			fi
			((total_shifts += 1))
			if ! shift; then
				__bake_internal_die 'Failed to shift'
			fi

			if [ ! -e "$BAKE_FILE" ]; then
				__bake_internal_die "Specified file '$BAKE_FILE' does not exist"
			fi
			if [ ! -f "$BAKE_FILE" ]; then
				__bake_internal_die "Specified file '$BAKE_FILE' is not actually a file"
			fi
		fi

		if [[ $__bake_arg == -*h* ]]; then
			__bake_flag_help='yes'
		fi

		if [[ $__bake_arg == -*u* ]]; then
			BAKE_INTERNAL_FLAG_UPDATE='yes'
		fi

		if [[ $__bake_arg == -*v* ]]; then
			printf '%s\n' "Version: $__global_bake_version"
			exit 0
		fi

		if [[ $__bake_arg == -*w* ]]; then
			if [[ ! -v 'BAKE_INTERNAL_NO_WATCH_OVERRIDE' ]]; then
				BAKE_INTERNAL_FLAG_WATCH='yes'
			fi
		fi
		;;
	*=*)
		# Set variables Ã  la Make
		IFS='=' read -r __bake_key __bake_value <<< "$__bake_arg"

		if [ "${__bake_key^^}" = "$__bake_key" ]; then
			# If 'KEY=value' is passed, create global variable $KEY
			declare -g "$__bake_key"
			local -n __bake_variable="$__bake_key"
			__bake_variable="$__bake_value"
		else
			# If 'key=value' is passed, create global variable $var_key
			# Applies to other non-caps keys like 'Key' and 'kEy' as well
			declare -g "var_$__bake_key"
			local -n __bake_variable="var_$__bake_key"
			__bake_variable="$__bake_value"
		fi

		((total_shifts += 1))
		if ! shift; then
			__bake_internal_die 'Failed to shift'
		fi
		;;
	*)
		break
		;;
	esac done; unset -v __bake_arg
	unset -v __bake_key __bake_value
	unset -vn __bake_variable

	if [ -n "$BAKE_FILE" ]; then
		BAKE_ROOT=$(
			# shellcheck disable=SC1007
			CDPATH= cd -- "${BAKE_FILE%/*}"
			printf '%s\n' "$PWD"
		)
		BAKE_FILE="$BAKE_ROOT/${BAKE_FILE##*/}"
	else
		if ! BAKE_ROOT=$(
			while [ ! -f './Bakefile.sh' ] && [ "$PWD" != / ]; do
				if ! cd ..; then
					exit 1
				fi
			done

			if [ "$PWD" = / ]; then
				exit 1
			fi

			printf '%s' "$PWD"
		); then
			__bake_internal_die "Failed to find 'Bakefile.sh'"
		fi
		BAKE_FILE="$BAKE_ROOT/Bakefile.sh"
	fi

	# This is at the end so 'BAKE_*' variables are set properly
	if [ "$__bake_flag_help" = 'yes' ]; then
		printf '%s\n' 'Usage: bake [-h|-v] [-u|-w] [-f <Bakefile>] [var=value ...] <task> [args ...]' >&2
		__bake_print_tasks
		exit
	fi

	REPLY=$total_shifts
}

# @description Main function
# @internal
__bake_main() {
	declare -ga __bake_args_original=("$@")

	# Parse arguments
	__bake_parse_args "$@"
	if ! shift $REPLY; then
		__bake_internal_die 'Failed to shift'
	fi

	local __bake_task="$1"
	if [ -z "$__bake_task" ]; then
		__bake_internal_error 'No valid task supplied'
		__bake_print_tasks
		exit 1
	fi
	if ! shift; then
		__bake_internal_die 'Failed to shift'
	fi

	declare -ga __bake_args_userflags=("$@")

	declare -g __bake_config_docstring=
	declare -ga __bake_config_watchexec_args=()
	declare -gA __bake_config_map=(
		[big-print]='on'
		[stacktrace]='off'
	)

	# watchexec
	if [ "$BAKE_INTERNAL_FLAG_WATCH" = 'yes' ]; then
		if ! command -v watchexec &>/dev/null; then
			__bake_internal_die "Executable not found: 'watchexec'"
		fi

		__bake_parse_task_comments "$__bake_task"

		# shellcheck disable=SC1007
		BAKE_INTERNAL_NO_WATCH_OVERRIDE= exec watchexec "${__bake_config_watchexec_args[@]}" "$BAKE_ROOT/bake" -- "${__bake_args_original[@]}"
	fi

	# start
	if ! cd -- "$BAKE_ROOT"; then
		__bake_internal_die "Failed to cd"
	fi

	# shellcheck disable=SC2097,SC1007,SC1090
	__bake_task= source "$BAKE_FILE"

	if declare -f task."$__bake_task" >/dev/null 2>&1; then
		__bake_parse_task_comments "$__bake_task"

		__bake_print_big "-> RUNNING TASK '$__bake_task'"

		if declare -f init >/dev/null 2>&1; then
			init "$__bake_task"
		fi

		__bake_time_prepare

		# Do NOT 'if task.*; then :; else handleIt; fi'
		task."$__bake_task" "${__bake_args_userflags[@]}"

		__bake_print_big --show-time "<- DONE"

		exit 0
	else
		__bake_internal_error "Task '$__bake_task' not found"
		__bake_print_tasks
		exit 1
	fi
}


# @description Tests if the './bake' file should be replaced. It should only
# be replaced if we're not in an interactive Git context
# @internal
__bake_setup_should_replace_bakescript() {
	local dir="$BAKE_ROOT"
	while [ ! -d "$dir/.git" ] && [ -n "$dir" ]; do
		dir=${dir%/*}
	done

	if [ -d "$dir/.git" ]; then
		# ref: https://github.com/git/git/blob/d420dda0576340909c3faff364cfbd1485f70376/wt-status.c#L1749
		# ref2: https://github.com/Byron/gitoxide/blob/375051fa97d79f95fa7179b536e616c4aefd88e2/git-repository/src/repository/state.rs#L8
		local file=
		for file in {rebase-apply/applying,rebase-apply/rebasing,rebase-apply,rebase-merge/interactive,rebase-merge,CHERRY_PICK_HEAD,MERGE_HEAD,BISECT_LOG,REVERT_HEAD}; do
			if [ -f "$dir/.git/$file" ]; then
				return 1
			fi
		done; unset -v file
	fi

	return 0
}

# @description Copy 'bake' script to current context
# @internal
__bake_setup_copy_bakescript() {
	# If there was an older version, and the versions are different, let the user know
	if [ -z ${__version_old+x} ]; then
		# shellcheck disable=SC2154
		# __bake_internal_warn "Updating from version <=1.10.0 to $__version_new"
		:
	else
		if [ -n "$__version_old" ] && [ "$__version_old" != "$__version_new" ]; then
			__bake_internal_warn "Updating from version $__version_old to $__version_new"
		fi
	fi

	# shellcheck disable=SC2154
	if ! cp -f "$0" "$BAKE_ROOT/bake"; then
		__bake_internal_die "Failed to copy 'bakeScript.sh'"
	fi

	if ! chmod +x "$BAKE_ROOT/bake"; then
		__bake_internal_die "Failed to 'chmod +x' bake script" >&2
	fi
}

__bake_entrypoint() {
	# Environment boilerplate
	set -ETeo pipefail
	shopt -s dotglob extglob globasciiranges globstar lastpipe shift_verbose
	if ((BASH_VERSINFO[0] >= 6 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] >= 2))); then
		shopt -s noexpand_translation
	fi
	export LANG='C' LC_CTYPE='C' LC_NUMERIC='C' LC_TIME='C' LC_COLLATE='C' \
		LC_MONETARY='C' LC_MESSAGES='C' LC_PAPER='C' LC_NAME='C' LC_ADDRESS='C' \
		LC_TELEPHONE='C' LC_MEASUREMENT='C' LC_IDENTIFICATION='C' LC_ALL='C'
	trap '__bake_trap_err' 'ERR'
	trap ':' 'INT' # Ensure Ctrl-C ends up printing <- ERROR ==== etc.

	# Argument parsing
	# shellcheck disable=SC2034
	declare -g BAKE_{FILE,ROOT}= BAKE_OLDPWD="$PWD" BAKE_INTERNAL_{FLAG_UPDATE,FLAG_WATCH}=
	__bake_parse_args "$@"
	if ! shift $REPLY; then
		__bake_internal_die 'Failed to shift'
	fi
	declare -g BAKE_INTERNAL_HAS_PARSED_ARGS='yes'

	local should_copy_bakescript='no'
	if [[ "$BAKE_INTERNAL_FLAG_UPDATE" = 'yes' || ! -f "$BAKE_ROOT/bake" ]]; then
		should_copy_bakescript='yes'
	fi

	local should_exec='no'
	if [ "$BAKE_INTERNAL_FLAG_UPDATE" = 'yes' ] || [[ "$BAKE_INTERNAL_FLAG_UPDATE" != 'yes' && ! -f "$BAKE_ROOT/bake" ]]; then
		should_exec='yes'
	fi

	# Only update the 'bake' script if we _have to_
	if [ "$should_copy_bakescript" = 'yes' ]; then
		# When we pass '-u', there is a potential for infinite loops. After updating the
		# file and 'exec'ing into it (done after this if-then block), the '-u' parameter will
		# still be passed, but we don't want to update it again.
		__bake_setup_copy_bakescript

		# local __version_new="$__global_bake_version"

		# We check if a 'bake' script already exists, so we can the "current" (pre-replacement) version, and tell
		# the user if the script is going to be updated. This requires some tricks, as mentioned below
		# if [ -f "$BAKE_ROOT/bake" ]; then
		# 	declare -ag __bake_global_backup_args=("$@")

		# These traps are required because 'BAKE_INTERNAL_ONLY_VERSION' is a recent addition. With older versions
		# that don't test for it, the source will run through the whole script, including the __bake_main
		# function (this is also why BAKE_INTERNAL_CAN_SOURCE=yes - so this feature doesn't cause older scripts
		# to just error and die). We use these traps to ensure the script does _not_ run __bake_main. Just "letting
		# it run" would make things more simple, but that would mean that we will have to run 'bake' twice to perform
		# the update, instead of just once (and it would not be guaranteed, since it updates at the end). Also, doing
		# this would mean values like "$0" are not what would be expected.
		# 	trap '__bake_trap_debug_barrier' DEBUG
		# 	# shellcheck disable=SC1091
		# 	BAKE_INTERNAL_ONLY_VERSION='yes' BAKE_INTERNAL_CAN_SOURCE='yes' source "$BAKE_ROOT/bake"
		# 	trap - DEBUG
		# 	__version_old=$__global_bake_version
		# 	unset -v __bake_global_backup_args
		# 	# TODO: re-source $0 so correct functions are in scope
		# fi
		__bake_main "$@"
	fi

	if [ "$should_exec" = 'yes' ]; then
		exec "$BAKE_ROOT/bake" "$@"
	else
		__bake_main "$@"
	fi
}










term.private_util_validate_p() {
	local args_excluding_flags="$1"
	if ! shift; then core.panic 'Failed to shift'; fi

	if (($# - 1 > args_excluding_flags)); then
		core.panic 'Incorrect argument count'
	elif (($# - 1 == args_excluding_flags)); then
		if [[ $1 == -?(@(p|P)) ]]; then
			case $1 in
			*p*) flag_print='yes' ;;
			*P*) flag_print='yes-newline' ;;
			esac
			REPLY_SHIFT=1
		else
			core.panic 'Invalid flag'
		fi
	else
		REPLY_SHIFT=0
	fi

}

term.private_util_validate_pd() {
	local args_excluding_flags="$1"
	if ! shift; then core.panic 'Failed to shift'; fi

	if (($# - 1 == args_excluding_flags)); then
		if [[ $1 == -?(d|@(p|P)|d@(p|P)|@(p|P)d) ]]; then
			case $1 in
			*p*) flag_print='yes' ;;
			*P*) flag_print='yes-newline' ;;
			esac
			if [[ $1 == *d* ]]; then
				end=$'\e[0m'
			fi
			REPLY_SHIFT=1
		else
			core.panic 'Invalid flag'
		fi
	elif (($# > args_excluding_flags)); then
		core.panic 'Incorrect argument count'
	else
		REPLY_SHIFT=0
	fi
}

term.private_util_set_reply() {
	local value="$1"

	REPLY="$value"
	term.private_util_replyprint
}

term.private_util_set_reply2() {
	# shellcheck disable=SC2059
	printf -v REPLY "$@"
	term.private_util_replyprint
}

term.private_util_replyprint() {
	if [ "$flag_print" = 'yes' ]; then
		printf '%s' "$REPLY"
	elif [ "$flag_print" = 'yes-newline' ]; then
		printf '%s\n' "$REPLY"
	fi
}

# -------------------------------------------------------- #
#                          Cursor                          #
# -------------------------------------------------------- #

# @description Move the cursor position to a supplied row and column. Both default to `0` if not supplied
# @arg $1 int row
# @arg $1 int column
term.cursor_to() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 2 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local row="${1:-0}"
	local column="${2:-0}"

	# Note that 'f' instead of 'H' is the 'force' variant
	term.private_util_set_reply2 '\033[%s;%sH' "$row" "$column"
}

# @description Moves cursor position to a supplied _relative_ row and column. Both default to `0` if not supplied (FIXME: implement)
# @arg $1 int row
# @arg $1 int column
term.cursor_moveto() {
	:
}

# @description Moves the cursor up. Defaults to `1` if not supplied
# @arg $1 int count
term.cursor_up() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local count="${1:-1}"

	term.private_util_set_reply2 '\033[%sA' "$count"
}

# @description Moves the cursor down. Defaults to `1` if not supplied
# @arg $1 int count
term.cursor_down() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local count="${1:-1}"

	term.private_util_set_reply2 '\033[%sB' "$count"
}

# @description Moves the cursor forward. Defaults to `1` if not supplied
# @arg $1 int count
term.cursor_forward() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local count="${1:-1}"

	term.private_util_set_reply2 '\033[%sC' "$count"
}

# @description Moves the cursor backwards. Defaults to `1` if not supplied
# @arg $1 int count
term.cursor_backward() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local count="${1:-1}"

	term.private_util_set_reply2 '\033[%sD' "$count"
}

# @description Moves the cursor to the next line. Defaults to `1` if not supplied
# @arg $1 int count
term.cursor_line_next() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local count="${1:-1}"

	term.private_util_set_reply2 '\033[%sE' "$count"
}

# @description Moves the cursor to the previous line. Defaults to `1` if not supplied
# @arg $1 int count
term.cursor_line_prev() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local count="${1:-1}"

	term.private_util_set_reply2 '\033[%sF' "$count"
}

# FIXME: docs
# @description Moves the cursor ?
# @arg $1 int count
term.cursor_horizontal() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local count="${1:-1}"

	term.private_util_set_reply2 '\033[%sG' "$count"
}

# @description Saves the current cursor position
# @noargs
term.cursor_savepos() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	if [ "$TERM_PROGRAM" = 'Apple_Terminal' ]; then
		REPLY=$'\u001B7'
	else
		REPLY=$'\e[s'
	fi
	term.private_util_replyprint
}

# @description Restores cursor to the last saved position
# @noargs
term.cursor_restorepos() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	if [ "$TERM_PROGRAM" = 'Apple_Terminal' ]; then
		REPLY=$'\u001B8'
	else
		REPLY=$'\e[u'
	fi
	term.private_util_replyprint
}

# FIXME: docs
# @description Saves
# @noargs
term.cursor_save() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[7'
}

# FIXME: docs
# @description Restores
# @noargs
term.cursor_restore() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[8'
}

# @description Hides the cursor
# @noargs
term.cursor_hide() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[?25l'
}

# @description Shows the cursor
# @noargs
term.cursor_show() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[?25h'
}

# @description Reports the cursor position to the application as (as though typed at the keyboard)
# @noargs
term.cursor_getpos() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[6n'
}

# -------------------------------------------------------- #
#                           Erase                          #
# -------------------------------------------------------- #

# @description Erase from the current cursor position to the end of the current line
# @noargs
term.erase_line_end() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	# Same as '\e[0K'
	term.private_util_set_reply $'\e[K'
}

# @description Erase from the current cursor position to the start of the current line
# @noargs
term.erase_line_start() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[1K'
}

# @description Erase the entire current line
# @noargs
term.erase_line() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[2K'
}

# @description Erase the screen from the current line down to the bottom of the screen
# @noargs
term.erase_screen_end() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	# Same as '\e[0J'
	term.private_util_set_reply $'\e[J'
}

# @description Erase the screen from the current line up to the top of the screen
# @noargs
term.erase_screen_start() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[1J'
}

# @description Erase the screen and move the cursor the top left position
# @noargs
term.erase_screen() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[2J'
}

# @noargs
term.erase_saved_lines() { # TODO: better name?
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[3J'
}

# -------------------------------------------------------- #
#                          Scroll                          #
# -------------------------------------------------------- #

# @noargs
term.scroll_down() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	# REPLY=$'\e[T'
	term.private_util_set_reply $'\e[D'
}

# @noargs
term.scroll_up() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	# REPLY=$'\e[S'
	term.private_util_set_reply $'\e[M'
}

# -------------------------------------------------------- #
#                            Tab                           #
# -------------------------------------------------------- #

# @noargs
term.tab_set() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[H'
}

# @noargs
term.tab_clear() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[g'
}

# @noargs
term.tab_clearall() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[3g'
}

# -------------------------------------------------------- #
#                          Screen                          #
# -------------------------------------------------------- #

# @description Save screen
# @noargs
term.screen_save() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[?1049h'
}

# @description Restore screen
# @noargs
term.screen_restore() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 0 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\e[?1049l'
}

# -------------------------------------------------------- #
#                           Color                          #
# -------------------------------------------------------- #

# @description Construct reset
# @arg $1 string text
term.style_reset() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 '\e[0m%s' "$text"
}

# @description Construct bold
# @arg $1 string text
term.style_bold() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1m%s%s" "$text" "$end"
}

# @description Construct dim
# @arg $1 string text
term.style_dim() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[2m%s%s" "$text" "$end"
}

# @description Construct italic
# @arg $1 string text
term.style_italic() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[3m%s%s" "$text" "$end"
}

# @description Construct underline
# @arg $1 string text
term.style_underline() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[4m%s%s" "$text" "$end"
}

# @description Construct inverse
# @arg $1 string text
term.style_inverse() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[7m%s%s" "$text" "$end"
}

# @description Construct hidden
# @arg $1 string text
term.style_hidden() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[8m%s%s" "$text" "$end"
}

# @description Construct strikethrough
# @arg $1 string text
term.style_strikethrough() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[9m%s%s" "$text" "$end"
}

# @description Construct hyperlink
# @arg $1 string text
# @arg $2 string url
term.style_hyperlink() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 2 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"
	local url="$2"

	term.private_util_set_reply2 '\e]8;;%s\a%s\e]8;;\a' "$url" "$text"
}

# @description Construct black color
# @arg $1 string text
term.color_black() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[30m%s%s" "$text" "$end"
}

# @description Construct red color
# @arg $1 string text
term.color_red() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[31m%s%s" "$text" "$end"
}

# @description Construct green color
# @arg $1 string text
term.color_green() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[32m%s%s" "$text" "$end"
}

# @description Construct orange color
# @arg $1 string text
term.color_orange() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[33m%s%s" "$text" "$end"
}

# @description Construct blue color
# @arg $1 string text
term.color_blue() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[34m%s%s" "$text" "$end"
}

# @description Construct purple color
# @arg $1 string text
term.color_purple() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[35m%s%s" "$text" "$end"
}

# @description Construct cyan color
# @arg $1 string text
term.color_cyan() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[36m%s%s" "$text" "$end"
}

# @description Construct light gray color
# @arg $1 string text
term.color_light_gray() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[37m%s%s" "$text" "$end"
}

# @description Construct dark gray color
# @arg $1 string text
term.color_dark_gray() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;30m%s%s" "$text" "$end"
}

# @description Construct light red color
# @arg $1 string text
term.color_light_red() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;31m%s%s" "$text" "$end"
}

# @description Construct light green color
# @arg $1 string text
term.color_light_green() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;32m%s%s" "$text" "$end"
}

# @description Construct yellow color
# @arg $1 string text
term.color_yellow() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;33m%s%s" "$text" "$end"
}

# @description Construct light blue color
# @arg $1 string text
term.color_light_blue() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;34m%s%s" "$text" "$end"
}

# @description Construct light purple color
# @arg $1 string text
term.color_light_purple() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;35m%s%s" "$text" "$end"
}

# @description Construct light cyan color
# @arg $1 string text
term.color_light_cyan() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;36m%s%s" "$text" "$end"
}

# @description Construct white color
# @arg $1 string text
term.color_white() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_pd 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	local text="$1"

	term.private_util_set_reply2 "\e[1;37m%s%s" "$text" "$end"
}

# -------------------------------------------------------- #
#                       Miscellaneous                      #
# -------------------------------------------------------- #

# @description Construct a beep
# @noargs
term.beep() {
	unset -v REPLY

	local flag_print='no' end=
	term.private_util_validate_p 1 "$@"
	shift "$REPLY_SHIFT" || core.panic 'Failed to shift'
	unset -v REPLY_SHIFT

	term.private_util_set_reply $'\a'
}

# -------------------------------------------------------- #
#                        Deprecated                        #
# -------------------------------------------------------- #

# @description (DEPRECATED) Construct hyperlink
# @arg $1 string text
# @arg $2 string url
term.hyperlink() {
	term.style_hyperlink "$@"
}

# @description (DEPRECATED) Construct bold
# @arg $1 string text
term.bold() {
	term.style_bold "$@"
}

# @description (DEPRECATED) Construct italic
# @arg $1 string text
term.italic() {
	term.style_italic "$@"
}

# @description (DEPRECATED) Construct underline
# @arg $1 string text
term.underline() {
	term.style_underline "$@"
}

# @description (DEPRECATED) Construct strikethrough
# @arg $1 string text
term.strikethrough() {
	term.style_strikethrough "$@"
}

# shellcheck shell=bash

# @description Initialize global variables required for shopt and trap functions
# @internal
core.private.util.init() {
	if [ ${___global_bash_core_has_init__+x} ]; then
		return
	fi

	___global_bash_core_has_init__=
	declare -gA ___global_trap_table___=()
	declare -ga ___global_shopt_stack___=()
}

# @description Function that runs handlers for a particular signal
# @internal
core.private.util.trap_handler_common() {
	local signal_spec="$1"
	local code="$2"

	local trap_handlers=
	IFS=$'\x1C' read -ra trap_handlers <<< "${___global_trap_table___[$signal_spec]}"

	local trap_handler=
	for trap_handler in "${trap_handlers[@]}"; do
		if [ -z "$trap_handler" ]; then
			continue
		fi

		if declare -f "$trap_handler" &>/dev/null; then
			if "$trap_handler" "$code"; then :; else
				return $?
			fi
		else
			core.print_warn "Trap handler function '$trap_handler' that was registered for signal '$signal_spec' no longer exists. Skipping" >&2
		fi
	done; unset -v trap_handler
}

# @internal
core.private.util.validate_args() {
	local function="$1"
	local arg_count="$2"

	if [ -z "$function" ]; then
		core.panic 'First argument must not be empty'
	fi

	if ((arg_count <= 1)); then
		core.panic 'Must specify at least one signal'
	fi
}

# @internal
core.private.util.validate_signal() {
	local function="$1"
	local signal_spec="$2"

	if [ -z "$signal_spec" ]; then
		core.panic 'Signal must not be an empty string'
	fi

	local regex='^[0-9]+$'
	if [[ "$signal_spec" =~ $regex ]]; then
		core.panic 'Passing numbers for the signal specs is prohibited'
	fi; unset -v regex
	signal_spec=${signal_spec#SIG}
	if ! declare -f "$function" &>/dev/null; then
		core.panic "Function '$function' is not defined"
	fi
}

# @description Determine if should print color, given a file descriptor
# @arg 1 File descriptor for terminal check
# @internal
core.private.should_print_color() {
	local fd="$1"

	if [ ${NO_COLOR+x} ]; then
		return 1
	fi

	if [[ $FORCE_COLOR == @(1|2|3) ]]; then
		return 0
	elif [[ $FORCE_COLOR == '0' ]]; then
		return 1
	fi

	if [ "$TERM" = 'dumb' ]; then
		return 1
	fi

	if [ -t "$fd" ]; then
		return 0
	fi

	return 1
}

# shellcheck shell=bash

# @name bash-core
# @description Core functions for any Bash program

# @description Adds a handler for a particular `trap` signal or event. Noticably,
# unlike the 'builtin' trap, this does not override any other existing handlers. The first argument
# to the handler is the exit code of the last command that ran before the particular 'trap'
# @arg $1 string Function to execute on an event. Integers are forbiden
# @arg $2 string Event signal
# @example
#   some_handler() { printf '%s\n' 'This was called on USR1! ^w^'; }
#   core.trap_add 'some_handler' 'USR1'
#   kill -USR1 $$
#   core.trap_remove 'some_handler' 'USR1'
core.trap_add() {
	core.private.util.init
	local function="$1"

	core.private.util.validate_args "$function" $#
	local signal_spec=
	for signal_spec in "${@:2}"; do
		core.private.util.validate_signal "$function" "$signal_spec"

		___global_trap_table___["$signal_spec"]="${___global_trap_table___[$signal_spec]}"$'\x1C'"$function"

		# rho (WET)
		local global_trap_handler_name=
		printf -v global_trap_handler_name '%q' "core.private.trap_handler_${signal_spec}"

		if ! eval "$global_trap_handler_name() {
		local ___exit_code_original=\$?
		if core.private.util.trap_handler_common '$signal_spec' \"\$___exit_code_original\"; then
			return \$___exit_code_original
		else
			local ___exit_code_user=\$?
			core.print_error_fn \"User-provided trap handler spectacularly failed with exit code \$___exit_code_user\"
			return \$___exit_code_user
		fi
	}"; then
			core.panic 'Failed to eval function'
		fi
		# shellcheck disable=SC2064
		trap "$global_trap_handler_name" "$signal_spec"
	done; unset -v signal_spec
}

# @description Removes a handler for a particular `trap` signal or event. Currently,
# if the function doest not exist, it prints an error
# @arg $1 string Function to remove
# @arg $2 string Signal that the function executed on
# @example
#   some_handler() { printf '%s\n' 'This was called on USR1! ^w^'; }
#   core.trap_add 'some_handler' 'USR1'
#   kill -USR1 $$
#   core.trap_remove 'some_handler' 'USR1'
core.trap_remove() {
	core.private.util.init
	local function="$1"

	core.private.util.validate_args "$function" $#
	local signal_spec=
	for signal_spec in "${@:2}"; do
		core.private.util.validate_signal "$function" "$signal_spec"

		local -a trap_handlers=()
		local new_trap_handlers=
		IFS=$'\x1C' read -ra trap_handlers <<< "${___global_trap_table___[$signal_spec]}"
		for trap_handler in "${trap_handlers[@]}"; do
			if [ -z "$trap_handler" ] || [ "$trap_handler" = $'\x1C' ]; then
				continue
			fi

			if [ "$trap_handler" = "$function" ]; then
				continue
			fi

			new_trap_handlers+=$'\x1C'"$trap_handler"
		done; unset -v trap_handler

		___global_trap_table___["$signal_spec"]="$new_trap_handlers"

		# If there are no more user-provided trap-handlers (for the particular signal spec in the global trap table),
		# then remove our handler from 'trap'
		if [ -z "$new_trap_handlers" ]; then
			# rho (WET)
			local global_trap_handler_name=
			printf -v global_trap_handler_name '%q' "core.private.trap_handler_${signal_spec}"
			trap -- "$signal_spec"
			unset -f "$global_trap_handler_name"
		fi
	done; unset -v signal_spec
}

# @description Modifies current shell options and pushes information to stack, so
# it can later be easily undone. Note that it does not check to see if your Bash
# version supports the option
# @arg $1 string Name of shopt action. Can either be `-u` or `-s`
# @arg $2 string Name of shopt name
# @example
#   core.shopt_push -s extglob
#   [[ 'variable' == @(foxtrot|golf|echo|variable) ]] && printf '%s\n' 'Woof!'
#   core.shopt_pop
core.shopt_push() {
	core.private.util.init
	local shopt_action="$1"
	local shopt_name="$2"

	if [ -z "$shopt_action" ]; then
		core.panic 'First argument cannot be empty'
	fi

	if [ -z "$shopt_name" ]; then
		core.panic 'Second argument cannot be empty'
	fi

	local -i previous_shopt_errcode=
	if shopt -q "$shopt_name"; then
		previous_shopt_errcode=$?
	else
		previous_shopt_errcode=$?
	fi

	if [ "$shopt_action" = '-s' ]; then
		if shopt -s "$shopt_name"; then :; else
			core.panic "Could not set shopt option" $?
		fi
	elif [ "$shopt_action" = '-u' ]; then
		if shopt -u "$shopt_name"; then :; else
			core.panic "Could not unset shopt option" $?
		fi
	else
		core.panic "Accepted actions are either '-s' or '-u'"
	fi

	if (( previous_shopt_errcode == 0)); then
		___global_shopt_stack___+=(-s "$shopt_name")
	else
		___global_shopt_stack___+=(-u "$shopt_name")
	fi
}

# @description Modifies current shell options based on most recent item added to stack.
# @noargs
# @example
#   core.shopt_push -s extglob
#   [[ 'variable' == @(foxtrot|golf|echo|variable) ]] && printf '%s\n' 'Woof!'
#   core.shopt_pop
core.shopt_pop() {
	core.private.util.init

	if (( ${#___global_shopt_stack___[@]} == 0 )); then
		core.panic 'Unable to pop as nothing is in the shopt stack'
	fi

	if (( ${#___global_shopt_stack___[@]} & 1 )); then
		core.panic 'Shopt stack is malformed'
	fi

	# Stack now guaranteed to have at least 2 elements (so the following accessors won't error)
	local shopt_action="${___global_shopt_stack___[-2]}"
	local shopt_name="${___global_shopt_stack___[-1]}"

	if shopt -u "$shopt_name"; then :; else
		core.panic 'Could not restore previous shopt option' $?
	fi

	___global_shopt_stack___=("${___global_shopt_stack___[@]::${#___global_shopt_stack___[@]}-2}")
}

# @description Sets an error.
# @arg $1 Error code
# @arg $2 Error message
# @set number ERRCODE Error code
# @set string ERR Error message
core.err_set() {
	if (($# == 1)); then
		ERRCODE=1
		ERR=$1
	elif (($# == 2)); then
		ERRCODE=$1
		ERR=$2
	else
		core.panic 'Incorrect function arguments'
	fi

	if [ -z "$ERR" ]; then
		core.panic "Argument for 'ERR' cannot be empty"
	fi
}

# @description Clears any of the global error state (sets to empty string).
# This means any `core.err_exists` calls after this _will_ `return 1`
# @noargs
# @set number ERRCODE Error code
# @set string ERR Error message
core.err_clear() {
	ERRCODE=
	ERR=
}

# @description Checks if an error exists. If `ERR` is not empty, then an error
# _does_ exist
# @noargs
core.err_exists() {
	if [ -z "$ERR" ]; then
		return 1
	else
		return 0
	fi
}

# @description Use when a serious fault occurs. It will print the current ERR (if it exists)
core.panic() {
	local code='1'
	if [[ $1 =~ [0-9]+ ]]; then
		code=$1
	elif [ -n "$1" ]; then
		if [ -n "$2" ]; then
			code=$2
		fi
		if core.private.should_print_color 2; then
			printf "\033[1;31m\033[4m%s:\033[0m %s\n" 'Panic' "$1" >&2
		else
			printf "%s: %s\n" 'Panic' "$1" >&2
		fi
	fi

	if core.err_exists; then
		printf '%s\n' 'Error found:' >&2
		printf '%s\n' "  ERRCODE: $ERRCODE" >&2
		printf '%s\n' "  ERR: $ERR" >&2
	fi

	core.print_stacktrace
	exit "$code"
}

# @description Prints stacktrace
# @noargs
# @example
#  err_handler() {
#    local exit_code=$1 # Note that this isn't `$?`
#    core.print_stacktrace
#
#    # Note that we're not doing `exit $exit_code` because
#    # that is handled automatically
#  }
#  core.trap_add 'err_handler' ERR
core.print_stacktrace() {
	printf '%s\n' 'Stacktrace:'

	local old_cd="$PWD" cd_failed='no'
	local i=
	for ((i=0; i<${#FUNCNAME[@]}-1; ++i)); do
		local file="${BASH_SOURCE[$i]}"

		# If the 'cd' has previous failed, then do not attempt to 'cd' as the current
		# directory is not in '$old_cd' (so the 'cd' will almost certainly fail)
		if [ "$cd_failed" = 'no' ]; then
			# shellcheck disable=SC1007
			if CDPATH= cd -- "${file%/*}"; then
				file="$PWD/${file##*/}"
			else
				cd_failed='yes'
			fi
		fi

		printf '%s\n' "  in ${FUNCNAME[$i]} ($file:${BASH_LINENO[$i-1]})"

		# shellcheck disable=SC1007
		if ! CDPATH= cd -- "$old_cd"; then
			cd_failed='yes'
		fi
	done; unset -v i

	if [ "$cd_failed" = 'yes' ]; then
		# Do NOT 'core.panic'
		core.print_error "A 'cd' failed, so the stacktrace may include relative paths"
	fi
} >&2

# @description Print a fatal error message including the function name of the callee
# to standard error
# @arg $1 string message
core.print_fatal_fn() {
	local msg="$1"

	core.print_fatal "${FUNCNAME[1]}()${msg:+": "}$msg"
}

# @description Print an error message including the function name of the callee
# to standard error
# @arg $1 string message
core.print_error_fn() {
	local msg="$1"

	core.print_error "${FUNCNAME[1]}()${msg:+": "}$msg"
}

# @description Print a warning message including the function name of the callee
# to standard error
# @arg $1 string message
core.print_warn_fn() {
	local msg="$1"

	core.print_warn "${FUNCNAME[1]}()${msg:+": "}$msg"
}

# @description Print an informative message including the function name of the callee
# to standard output
# @arg $1 string message
core.print_info_fn() {
	local msg="$1"

	core.print_info "${FUNCNAME[1]}()${msg:+": "}$msg"
}
# @description Print a debug message including the function name of the callee
# to standard output
# @arg $1 string message
core.print_debug_fn() {
	local msg="$1"

	core.print_debug "${FUNCNAME[1]}()${msg:+": "}$msg"
}

# @description Print a fatal error message to standard error
# @arg $1 string message
core.print_fatal() {
	local msg="$1"

	if core.private.should_print_color 2; then
		printf "\033[1;35m%s:\033[0m %s\n" 'Fatal' "$msg" >&2
	else
		printf "%s: %s\n" 'Fatal' "$msg" >&2
	fi
}

# @description Print an error message to standard error
# @arg $1 string message
core.print_error() {
	local msg="$1"

	if core.private.should_print_color 2; then
		printf "\033[1;31m%s:\033[0m %s\n" 'Error' "$msg" >&2
	else
		printf "%s: %s\n" 'Error' "$msg" >&2
	fi
}

# @description Print a warning message to standard error
# @arg $1 string message
core.print_warn() {
	local msg="$1"

	if core.private.should_print_color 2; then
		printf "\033[1;33m%s:\033[0m %s\n" 'Warn' "$msg" >&2
	else
		printf "%s: %s\n" 'Warn' "$msg" >&2
	fi
}

# @description Print an informative message to standard output
# @arg $1 string message
core.print_info() {
	local msg="$1"

	if core.private.should_print_color 1; then
		printf "\033[1;32m%s:\033[0m %s\n" 'Info' "$msg"
	else
		printf "%s: %s\n" 'Info' "$msg"
	fi
}

# @description Print a debug message to standard output if the environment variable "DEBUG" is present
# @arg $1 string message
core.print_debug() {
	if [[ -v DEBUG ]]; then
		printf "%s: %s\n" 'Debug' "$msg"
	fi
}

core.ifs_save() {
	local new_ifs="$1"

	___global_ifs_variable_saved___=$IFS
	IFS=$new_ifs
}

core.ifs_restore() {
	IFS=$___global_ifs_variable_saved___
}

# @description (DEPRECATED). Determine if color should be printed. Note that this doesn't
# use tput because simple environment variable checking heuristics suffice. Deprecated because this code
# has been moved to bash-std
core.should_output_color() {
	if core.private.should_print_color "$@"; then :; else
		return $?
	fi
}

# @description (DEPRECATED) Gets information from a particular package. If the key does not exist, then the value
# is an empty string. Deprecated as this code has been moved to bash-std
# @arg $1 string The `$BASALT_PACKAGE_DIR` of the caller
# @set directory string The full path to the directory
core.get_package_info() {
	unset REPLY; REPLY=
	local basalt_package_dir="$1"
	local key_name="$2"

	local toml_file="$basalt_package_dir/basalt.toml"

	if [ ! -f "$toml_file" ]; then
		core.panic "File '$toml_file' could not be found"
	fi

	local regex=$'^[ \t]*'"${key_name}"$'[ \t]*=[ \t]*[\'"](.*)[\'"]'
	while IFS= read -r line || [ -n "$line" ]; do
		if [[ $line =~ $regex ]]; then
			REPLY=${BASH_REMATCH[1]}
			break
		fi
	done < "$toml_file"; unset -v line
}

# @description (DEPRECATED) Initiates global variables used by other functions. Deprecated as
# this function is called automatically by functions that use global variables
# @noargs
core.init() {
	core.private.util.init
}

# @description (DEPRECATED) Prints stacktrace
# @see core.print_stacktrace
core.stacktrace_print() {
	core.print_warn "The function 'core.stacktrace_print' is deprecated in favor of 'core.print_stacktrace'"
	core.print_stacktrace "$@"
}

# @description (DEPRECATED) Print a error message to standard error including the function name
# of the callee to standard error and die
# @arg $1 string message
core.print_die_fn() {
	local msg="$1"

	core.print_die "${FUNCNAME[1]}()${msg:+": "}$msg"
}

# @description (DEPRECATED) Print a error message to standard error and die
# @arg $1 string message
core.print_die() {
	core.print_fatal "$1"
	exit 1
}

__bake_entrypoint "$@"
